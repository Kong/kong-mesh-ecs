name: "Nightly Kong Mesh on ECS Multizone"
run-name: "Nightly Kong Mesh Multizone on ECS - ${{ inputs.version || 'preview' }}"

concurrency:
  group: ${{github.workflow}}

on:
  workflow_dispatch:
    inputs:
      version:
        description: Kong Mesh version to build (same format as installer.sh). Otherwise latest preview is used.
        type: string
      skip-cleanup:
        description: Skip resource cleanup
        type: boolean
        required: false
  schedule:
    - cron: "25 4 * * *"
  push:
    branches:
      - main

env:
  stack-prefix: ecs-ci
  unique-id: ${{ github.run_number }}_${{ github.run_attempt}}

permissions:
  id-token: write
  contents: read

# In the AWS account, GitHub is registered as an OIDC provider.
# There is also an IAM role that trusts tokens issued by this provider to this
# main branch in this repository. The role has permissions necessary to create
# and delete the stacks in this repo (see /policy.json).
#
# When the GitHub workflow runs, it is issued such an OIDC token by the GitHub OIDC
# provider and uses the `configure-aws-credentials` action to obtain short-lived
# credentials and then assume the aforementioned IAM role.
#
# This workflow deploys two Kong Mesh zones (us-west-1 and us-east-2) concurrently,
# connecting them to a global control plane on Konnect.
jobs:
  deploy-zone-west:
    timeout-minutes: 30
    name: "Deploy Zone us-west-1"
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: /usr/bin/bash -Eeuo pipefail {0}
    outputs:
      license-secret: ${{ steps.cp.outputs.license-secret }}
      tls-key-secret: ${{ steps.cp.outputs.tls-key-secret }}
      tls-cert-secret: ${{ steps.cp.outputs.tls-cert-secret }}
      cp-token-secret: ${{ steps.cp.outputs.cp-token-secret }}
      cp-addr: ${{ steps.cp.outputs.cp-addr }}
      hosted-zone-id: ${{ steps.vpc.outputs.hosted-zone-id }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 #v5.1.0
        with:
          role-to-assume: arn:aws:iam::${{ secrets.NIGHTLY_AWS_ACCOUNT_ID }}:role/ecs-ci
          aws-region: us-west-1
      - name: Generate GitHub app token
        id: github-app-token
        uses: tibdex/github-app-token@3beb63f4bd073e61482598c45c71c1019b59b73a # v2.1.0
        with:
          app_id: ${{ vars.KONG_MESH_APP_ID }}
          private_key: ${{ secrets.KONG_MESH_APP_PRIVATE_KEY }}
      - name: Get version
        id: version
        env:
          GH_TOKEN: ${{ steps.github-app-token.outputs.token }}
        run: |
          version="${{ inputs.version }}"
          if [[ -z "${version}" ]] || [[ "${version}" == "preview" ]]; then
            version=$(curl --silent -L https://docs.konghq.com/mesh/installer.sh  | VERSION=preview sh -s - --print-version | tail -n1)
          fi
          echo "version=${version}" >> $GITHUB_OUTPUT
      - name: Install kumactl
        run: |
          curl -L https://docs.konghq.com/mesh/installer.sh | VERSION="${{ steps.version.outputs.version }}" sh -
          cp kong-mesh-*/bin/kumactl /usr/local/bin/kumactl
      - name: Provision VPC
        id: vpc
        run: |
          aws cloudformation deploy \
            --capabilities CAPABILITY_IAM \
            --stack-name ${{ env.stack-prefix}}-vpc \
            --template-file deploy/vpc.yaml

          HOSTED_ZONE_ID=$(
            aws cloudformation describe-stacks --stack-name ${{ env.stack-prefix}}-vpc \
            | jq -r '.Stacks[0].Outputs[] | select(.OutputKey == "HostedZoneId") | .OutputValue'
          )

          echo "hosted-zone-id=${HOSTED_ZONE_ID}" >> $GITHUB_OUTPUT
      - name: Provision zone control plane
        id: cp
        env:
          license: ${{ secrets.KONG_MESH_LICENSE_JSON }}
          kds_address: ${{ secrets.KONNECT_KDS_ADDRESS }}
          konnect_cp_id: ${{ secrets.KONNECT_CP_ID }}
        run: |
          LICENSE_SECRET=$(
            aws secretsmanager create-secret \
                --name ${{ env.stack-prefix }}/KongMeshLicense/west/${{ env.unique-id }} \
                --description "Secret containing Kong Mesh license" \
                --secret-string "${license}"
          )

          CP_ADDR=$(
            aws cloudformation describe-stacks --stack-name ${{ env.stack-prefix}}-vpc \
            | jq -r '.Stacks[0].Outputs[] | select(.OutputKey == "ExternalCPAddress") | .OutputValue'
          )

          kumactl generate tls-certificate --type=server --hostname ${CP_ADDR} --hostname controlplane.kongmesh
          TLS_KEY=$(
            aws secretsmanager create-secret \
              --name ${{ env.stack-prefix }}/CPTLSKey/west/${{ env.unique-id }} \
              --description "Secret containing TLS private key for serving control plane traffic" \
              --secret-string file://key.pem
          )
          TLS_CERT=$(
            aws secretsmanager create-secret \
              --name ${{ env.stack-prefix }}/CPTLSCert/west/${{ env.unique-id }} \
              --description "Secret containing TLS certificate for serving control plane traffic" \
              --secret-string file://cert.pem
          )

          # Create secret for Konnect CP token
          CP_TOKEN_SECRET=$(
            aws secretsmanager create-secret \
                --name ${{ env.stack-prefix }}/KonnectCPToken/west/${{ env.unique-id }} \
                --description "Secret holding the global control plane token on Konnect" \
                --secret-string "${{ secrets.KONNECT_CP_TOKEN }}"
          )

          aws cloudformation deploy \
              --capabilities CAPABILITY_IAM \
              --stack-name ${{ env.stack-prefix}}-cp \
              --parameter-overrides VPCStackName=${{ env.stack-prefix }}-vpc \
                ZoneName=ecs-us-west-1 \
                GlobalKDSAddress=${kds_address} \
                GlobalCPTokenSecret=$(jq -r .ARN <<< $CP_TOKEN_SECRET) \
                KonnectCPId=${konnect_cp_id} \
                Image="docker.io/kong/kuma-cp:${{ steps.version.outputs.version }}" \
                LicenseSecret=$(jq -r .ARN <<< $LICENSE_SECRET) \
                ServerKeySecret=$(jq -r .ARN <<< $TLS_KEY) \
                ServerCertSecret=$(jq -r .ARN <<< $TLS_CERT) \
              --template-file deploy/controlplane.yaml

          echo "license-secret=$(jq -r .Name <<< $LICENSE_SECRET)" >> $GITHUB_OUTPUT
          echo "cp-addr=${CP_ADDR}" >> $GITHUB_OUTPUT
          echo "tls-key-secret=$(jq -r .Name <<< $TLS_KEY)" >> $GITHUB_OUTPUT
          echo "tls-cert-secret=$(jq -r .Name <<< $TLS_CERT)" >> $GITHUB_OUTPUT
          echo "cp-token-secret=$(jq -r .Name <<< $CP_TOKEN_SECRET)" >> $GITHUB_OUTPUT
      - name: Provision ingress
        run: |
          aws cloudformation deploy \
            --capabilities CAPABILITY_IAM \
            --stack-name ${{ env.stack-prefix }}-ingress \
            --parameter-overrides \
              SidecarImage="docker.io/kong/kuma-dp:${{ steps.version.outputs.version }}" \
              VPCStackName=${{ env.stack-prefix }}-vpc \
              CPStackName=${{ env.stack-prefix }}-cp \
            --template-file deploy/ingress.yaml
      - name: Provision counter-demo
        run: |
          aws cloudformation deploy \
            --capabilities CAPABILITY_IAM \
            --stack-name ${{ env.stack-prefix }}-kv \
            --parameter-overrides \
              SidecarImage="docker.io/kong/kuma-dp:${{ steps.version.outputs.version }}" \
              VPCStackName=${{ env.stack-prefix }}-vpc \
              CPStackName=${{ env.stack-prefix }}-cp \
            --template-file deploy/counter-demo/kv.yaml

          aws cloudformation deploy \
            --capabilities CAPABILITY_IAM \
            --stack-name ${{ env.stack-prefix }}-demo-app \
            --parameter-overrides \
              SidecarImage="docker.io/kong/kuma-dp:${{ steps.version.outputs.version }}" \
              VPCStackName=${{ env.stack-prefix }}-vpc \
              CPStackName=${{ env.stack-prefix }}-cp \
            --template-file deploy/counter-demo/demo-app.yaml

  deploy-zone-east:
    timeout-minutes: 30
    name: "Deploy Zone us-east-2"
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: /usr/bin/bash -Eeuo pipefail {0}
    outputs:
      license-secret: ${{ steps.cp.outputs.license-secret }}
      tls-key-secret: ${{ steps.cp.outputs.tls-key-secret }}
      tls-cert-secret: ${{ steps.cp.outputs.tls-cert-secret }}
      cp-token-secret: ${{ steps.cp.outputs.cp-token-secret }}
      cp-addr: ${{ steps.cp.outputs.cp-addr }}
      hosted-zone-id: ${{ steps.vpc.outputs.hosted-zone-id }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 #v5.1.0
        with:
          role-to-assume: arn:aws:iam::${{ secrets.NIGHTLY_AWS_ACCOUNT_ID }}:role/ecs-ci
          aws-region: us-east-2
      - name: Generate GitHub app token
        id: github-app-token
        uses: tibdex/github-app-token@3beb63f4bd073e61482598c45c71c1019b59b73a # v2.1.0
        with:
          app_id: ${{ vars.KONG_MESH_APP_ID }}
          private_key: ${{ secrets.KONG_MESH_APP_PRIVATE_KEY }}
      - name: Get version
        id: version
        env:
          GH_TOKEN: ${{ steps.github-app-token.outputs.token }}
        run: |
          version="${{ inputs.version }}"
          if [[ -z "${version}" ]] || [[ "${version}" == "preview" ]]; then
            version=$(curl --silent -L https://docs.konghq.com/mesh/installer.sh  | VERSION=preview sh -s - --print-version | tail -n1)
          fi
          echo "version=${version}" >> $GITHUB_OUTPUT
      - name: Install kumactl
        run: |
          curl -L https://docs.konghq.com/mesh/installer.sh | VERSION="${{ steps.version.outputs.version }}" sh -
          cp kong-mesh-*/bin/kumactl /usr/local/bin/kumactl
      - name: Provision VPC
        id: vpc
        run: |
          aws cloudformation deploy \
            --capabilities CAPABILITY_IAM \
            --stack-name ${{ env.stack-prefix}}-vpc \
            --template-file deploy/vpc.yaml

          HOSTED_ZONE_ID=$(
            aws cloudformation describe-stacks --stack-name ${{ env.stack-prefix}}-vpc \
            | jq -r '.Stacks[0].Outputs[] | select(.OutputKey == "HostedZoneId") | .OutputValue'
          )

          echo "hosted-zone-id=${HOSTED_ZONE_ID}" >> $GITHUB_OUTPUT
      - name: Provision zone control plane
        id: cp
        env:
          license: ${{ secrets.KONG_MESH_LICENSE_JSON }}
          kds_address: ${{ secrets.KONNECT_KDS_ADDRESS }}
          konnect_cp_id: ${{ secrets.KONNECT_CP_ID }}
        run: |
          LICENSE_SECRET=$(
            aws secretsmanager create-secret \
                --name ${{ env.stack-prefix }}/KongMeshLicense/east/${{ env.unique-id }} \
                --description "Secret containing Kong Mesh license" \
                --secret-string "${license}"
          )

          CP_ADDR=$(
            aws cloudformation describe-stacks --stack-name ${{ env.stack-prefix}}-vpc \
            | jq -r '.Stacks[0].Outputs[] | select(.OutputKey == "ExternalCPAddress") | .OutputValue'
          )

          kumactl generate tls-certificate --type=server --hostname ${CP_ADDR} --hostname controlplane.kongmesh
          TLS_KEY=$(
            aws secretsmanager create-secret \
              --name ${{ env.stack-prefix }}/CPTLSKey/east/${{ env.unique-id }} \
              --description "Secret containing TLS private key for serving control plane traffic" \
              --secret-string file://key.pem
          )
          TLS_CERT=$(
            aws secretsmanager create-secret \
              --name ${{ env.stack-prefix }}/CPTLSCert/east/${{ env.unique-id }} \
              --description "Secret containing TLS certificate for serving control plane traffic" \
              --secret-string file://cert.pem
          )

          # Create secret for Konnect CP token
          CP_TOKEN_SECRET=$(
            aws secretsmanager create-secret \
                --name ${{ env.stack-prefix }}/KonnectCPToken/east/${{ env.unique-id }} \
                --description "Secret holding the global control plane token on Konnect" \
                --secret-string "${{ secrets.KONNECT_CP_TOKEN }}"
          )

          aws cloudformation deploy \
              --capabilities CAPABILITY_IAM \
              --stack-name ${{ env.stack-prefix}}-cp \
              --parameter-overrides VPCStackName=${{ env.stack-prefix }}-vpc \
                ZoneName=ecs-us-east-2 \
                GlobalKDSAddress=${kds_address} \
                GlobalCPTokenSecret=$(jq -r .ARN <<< $CP_TOKEN_SECRET) \
                KonnectCPId=${konnect_cp_id} \
                Image="docker.io/kong/kuma-cp:${{ steps.version.outputs.version }}" \
                LicenseSecret=$(jq -r .ARN <<< $LICENSE_SECRET) \
                ServerKeySecret=$(jq -r .ARN <<< $TLS_KEY) \
                ServerCertSecret=$(jq -r .ARN <<< $TLS_CERT) \
              --template-file deploy/controlplane.yaml

          echo "license-secret=$(jq -r .Name <<< $LICENSE_SECRET)" >> $GITHUB_OUTPUT
          echo "cp-addr=${CP_ADDR}" >> $GITHUB_OUTPUT
          echo "tls-key-secret=$(jq -r .Name <<< $TLS_KEY)" >> $GITHUB_OUTPUT
          echo "tls-cert-secret=$(jq -r .Name <<< $TLS_CERT)" >> $GITHUB_OUTPUT
          echo "cp-token-secret=$(jq -r .Name <<< $CP_TOKEN_SECRET)" >> $GITHUB_OUTPUT
      - name: Provision ingress
        run: |
          aws cloudformation deploy \
            --capabilities CAPABILITY_IAM \
            --stack-name ${{ env.stack-prefix }}-ingress \
            --parameter-overrides \
              SidecarImage="docker.io/kong/kuma-dp:${{ steps.version.outputs.version }}" \
              VPCStackName=${{ env.stack-prefix }}-vpc \
              CPStackName=${{ env.stack-prefix }}-cp \
            --template-file deploy/ingress.yaml
      - name: Provision counter-demo
        run: |
          aws cloudformation deploy \
            --capabilities CAPABILITY_IAM \
            --stack-name ${{ env.stack-prefix }}-kv \
            --parameter-overrides \
              SidecarImage="docker.io/kong/kuma-dp:${{ steps.version.outputs.version }}" \
              VPCStackName=${{ env.stack-prefix }}-vpc \
              CPStackName=${{ env.stack-prefix }}-cp \
            --template-file deploy/counter-demo/kv.yaml

          aws cloudformation deploy \
            --capabilities CAPABILITY_IAM \
            --stack-name ${{ env.stack-prefix }}-demo-app \
            --parameter-overrides \
              SidecarImage="docker.io/kong/kuma-dp:${{ steps.version.outputs.version }}" \
              VPCStackName=${{ env.stack-prefix }}-vpc \
              CPStackName=${{ env.stack-prefix }}-cp \
            --template-file deploy/counter-demo/demo-app.yaml

  apply-policies:
    timeout-minutes: 10
    needs: [deploy-zone-west, deploy-zone-east]
    name: "Apply Global Policies"
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: /usr/bin/bash -Eeuo pipefail {0}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      - name: Generate GitHub app token
        id: github-app-token
        uses: tibdex/github-app-token@3beb63f4bd073e61482598c45c71c1019b59b73a # v2.1.0
        with:
          app_id: ${{ vars.KONG_MESH_APP_ID }}
          private_key: ${{ secrets.KONG_MESH_APP_PRIVATE_KEY }}
      - name: Get version
        id: version
        env:
          GH_TOKEN: ${{ steps.github-app-token.outputs.token }}
        run: |
          version="${{ inputs.version }}"
          if [[ -z "${version}" ]] || [[ "${version}" == "preview" ]]; then
            version=$(curl --silent -L https://docs.konghq.com/mesh/installer.sh  | VERSION=preview sh -s - --print-version | tail -n1)
          fi
          echo "version=${version}" >> $GITHUB_OUTPUT
      - name: Install kumactl
        run: |
          curl -L https://docs.konghq.com/mesh/installer.sh | VERSION="${{ steps.version.outputs.version }}" sh -
          cp kong-mesh-*/bin/kumactl /usr/local/bin/kumactl
      - name: Configure kumactl for Konnect
        env:
          konnect_token: ${{ secrets.KONNECT_CP_KPAT }}
          konnect_cp_id: ${{ secrets.KONNECT_CP_ID }}
        run: |
          kumactl config control-planes add \
            --address=https://us.api.konghq.com/v1/mesh/control-planes/${konnect_cp_id}/api \
            --headers "authorization=Bearer ${konnect_token}" \
            --name "konnect_ecs-global_us"
            --overwrite
      - name: Process and apply policies
        env:
          west_zone_id: ${{ needs.deploy-zone-west.outputs.hosted-zone-id }}
          east_zone_id: ${{ needs.deploy-zone-east.outputs.hosted-zone-id }}
        run: |
          # Replace placeholders in hg.yaml
          sed -e "s/HOSTED_ZONE_ID_WEST_1/${west_zone_id}/g" \
              -e "s/HOSTED_ZONE_ID_EAST_2/${east_zone_id}/g" \
              resources/hg.yaml > /tmp/hg-processed.yaml

          echo "Processed HostnameGenerator configuration:"
          cat /tmp/hg-processed.yaml

          # Apply policies to global control plane
          echo "Applying Mesh configuration..."
          kumactl apply -f resources/mesh.yaml

          echo "Applying MeshTrafficPermission..."
          kumactl apply -f resources/mtp.yaml

          echo "Applying MeshMultiZoneService..."
          kumactl apply -f resources/mzms.yaml

          echo "Applying HostnameGenerator with zone-specific hosted zone IDs..."
          kumactl apply -f /tmp/hg-processed.yaml

  test:
    timeout-minutes: 30
    needs: [deploy-zone-west, deploy-zone-east, apply-policies]
    name: "Test Multizone Setup"
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: /usr/bin/bash -Eeuo pipefail {0}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      - name: Test west zone dataplanes
        run: |
          echo "Testing us-west-1 zone..."
          # Connect to Konnect global CP to verify zones and dataplanes
          # This would require kumactl configured to Konnect global CP
          echo "West zone CP: ${{ needs.deploy-zone-west.outputs.cp-addr }}"
      - name: Test east zone dataplanes
        run: |
          echo "Testing us-east-2 zone..."
          echo "East zone CP: ${{ needs.deploy-zone-east.outputs.cp-addr }}"
      - name: Test counter-demo in west zone
        run: |
          sudo apt-get install httpie

          echo "Ensuring open TCP connection to demo app listener in us-west-1..."
          for i in {1..5}; do
            netcat -w 180 -z ${{ needs.deploy-zone-west.outputs.cp-addr }} 80 || true
          done

          echo "Set zone name"
          http --check-status POST http://${{ needs.deploy-zone-west.outputs.cp-addr }}:15050/api/key-value/zone value=us-west-1
      - name: Test counter-demo in east zone
        run: |
          echo "Ensuring open TCP connection to demo app listener in us-east-2..."
          for i in {1..5}; do
            netcat -w 180 -z ${{ needs.deploy-zone-east.outputs.cp-addr }} 80 || true
          done

          echo "Set zone name"
          http --check-status POST http://${{ needs.deploy-zone-east.outputs.cp-addr }}:15050/api/key-value/zone value=us-east-2
      - name: Test cross-zone load balancing
        run: |
          echo "Testing cross-zone load balancing via multizone service..."

          # Initialize counters for each zone
          WEST_COUNT=0
          EAST_COUNT=0
          UNKNOWN_COUNT=0
          TOTAL_REQUESTS=10

          for i in $(seq 1 $TOTAL_REQUESTS); do
            # Make request to counter endpoint (using west zone endpoint as entry point)
            RESPONSE=$(http --ignore-stdin GET http://${{ needs.deploy-zone-west.outputs.cp-addr }}/api/counter)
            ZONE=$(echo "$RESPONSE" | jq -r '.zone // "unknown"')

            echo "Request $i: Response from zone: $ZONE"

            # Increment appropriate counter
            case "$ZONE" in
              us-west-1)
                WEST_COUNT=$((WEST_COUNT + 1))
                ;;
              us-east-2)
                EAST_COUNT=$((EAST_COUNT + 1))
                ;;
              *)
                UNKNOWN_COUNT=$((UNKNOWN_COUNT + 1))
                ;;
            esac

            sleep 1
          done

          echo ""
          echo "=== Cross-Zone Load Balancing Results ==="

          if [ "$WEST_COUNT" -gt 0 ]; then
            WEST_PCT=$((WEST_COUNT * 100 / TOTAL_REQUESTS))
            echo "Zone us-west-1: $WEST_COUNT requests (${WEST_PCT}%)"
          fi

          if [ "$EAST_COUNT" -gt 0 ]; then
            EAST_PCT=$((EAST_COUNT * 100 / TOTAL_REQUESTS))
            echo "Zone us-east-2: $EAST_COUNT requests (${EAST_PCT}%)"
          fi

          if [ "$UNKNOWN_COUNT" -gt 0 ]; then
            echo "Zone unknown: $UNKNOWN_COUNT requests"
          fi

          # Verify both zones received requests
          if [ "$WEST_COUNT" -gt 0 ] && [ "$EAST_COUNT" -gt 0 ]; then
            echo ""
            echo "✓ SUCCESS: Traffic distributed across both zones (us-west-1 and us-east-2)"
          else
            echo ""
            echo "✗ FAILURE: Traffic not distributed across both zones"
            echo "West zone requests: $WEST_COUNT"
            echo "East zone requests: $EAST_COUNT"
            exit 1
          fi

  teardown:
    timeout-minutes: 30
    needs: [test, deploy-zone-west, deploy-zone-east]
    name: "Cleanup"
    if: 'always() && !inputs.skip-cleanup'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        region:
          - name: west
            aws-region: us-west-1
            license-secret: ${{ needs.deploy-zone-west.outputs.license-secret }}
            tls-key-secret: ${{ needs.deploy-zone-west.outputs.tls-key-secret }}
            tls-cert-secret: ${{ needs.deploy-zone-west.outputs.tls-cert-secret }}
            cp-token-secret: ${{ needs.deploy-zone-west.outputs.cp-token-secret }}
          - name: east
            aws-region: us-east-2
            license-secret: ${{ needs.deploy-zone-east.outputs.license-secret }}
            tls-key-secret: ${{ needs.deploy-zone-east.outputs.tls-key-secret }}
            tls-cert-secret: ${{ needs.deploy-zone-east.outputs.tls-cert-secret }}
            cp-token-secret: ${{ needs.deploy-zone-east.outputs.cp-token-secret }}
    steps:
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@00943011d9042930efac3dcd3a170e4273319bc8 #v5.1.0
        with:
          role-to-assume: arn:aws:iam::${{ secrets.NIGHTLY_AWS_ACCOUNT_ID }}:role/ecs-ci
          aws-region: ${{ matrix.region.aws-region }}
      - name: Deprovision counter-demo, kv and ingress
        run: |
          aws cloudformation delete-stack \
            --stack-name ${{ env.stack-prefix}}-demo-app-${{ matrix.region.name }}
          aws cloudformation delete-stack \
            --stack-name ${{ env.stack-prefix}}-kv-${{ matrix.region.name }}
          aws cloudformation delete-stack \
            --stack-name ${{ env.stack-prefix}}-ingress-${{ matrix.region.name }}

          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.stack-prefix}}-demo-app-${{ matrix.region.name }}
          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.stack-prefix}}-kv-${{ matrix.region.name }}
          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.stack-prefix}}-ingress-${{ matrix.region.name }}
      - name: Deprovision control plane
        run: |
          aws cloudformation delete-stack \
            --stack-name ${{ env.stack-prefix}}-cp-${{ matrix.region.name }}
          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.stack-prefix}}-cp-${{ matrix.region.name }}

          aws secretsmanager delete-secret --secret-id ${{ matrix.region.tls-key-secret }}
          aws secretsmanager delete-secret --secret-id ${{ matrix.region.tls-cert-secret }}
          aws secretsmanager delete-secret --secret-id ${{ matrix.region.license-secret }}
          aws secretsmanager delete-secret --secret-id ${{ matrix.region.cp-token-secret }}
      - name: Deprovision VPC
        run: |
          aws cloudformation delete-stack \
            --stack-name ${{ env.stack-prefix}}-vpc-${{ matrix.region.name }}
          aws cloudformation wait stack-delete-complete \
            --stack-name ${{ env.stack-prefix}}-vpc-${{ matrix.region.name }}
